Creating a React + TypeScript Project?
 Now in the last section,  we got started with TypeScript,  though only in theory, of course.  Now there we mostly worked in this code editor  but I did mention this compiler  which you can invoke by running npx tsc,  at least if you did not install TypeScript  into your local project  which we didn't do in that section.  Now you can use that compiler  to then target a specific file.  For example, first-app.ts  which is the file we worked on there.  And if you then hit Enter  this file gets converted to a JavaScript file.  And before that conversion happens  TypeScript will actually check that file  for errors, though, as you saw in the last section,  most errors, pretty much all errors,  can already be seen right in the IDE  before you even invoke the compiler.  Nonetheless, you then get this JavaScript file  which then is the file  that you could include in the browser  because that file then doesn't contain  any TypeScript code anymore.  And as you can see, if you take a look at that code,  the code even gets converted such  that it works with older JavaScript versions  in case you're building for an older browser.  Now in this section that's going to change though,  we're not going to invoke the compiler  by running this npx tsc command anymore.  Instead, now we're going to switch to a React project  where the compiler will be part of that project  and where it will actually be part  of a build pipeline that can be invoked  when we want to prepare  our overall application for production.  Because as you might know, React code,  even when not using TypeScript, also must be converted such  that it works in the browser because this JSX code  which you write all the time when working with React  doesn't work in the browser like this.  So the code must be converted  and also as it turns out, optimized anyways.  And therefore this TypeScript compilation  will now just be another part of that build process.  Therefore, what we'll do for this section here  is we'll create a new project by running npm create  for which you need to have node.js installed on your system  and then use the vite build tool for creating that project.  And also then later inside of that project  for running the dev server  and for building the code and optimizing it for production.  And here I'll ensure that I'm using the latest version.  And I'll name my project react-ts-basics  because that's what we'll explore in this project  and this section.  If I now hit Enter I get this prompt  to choose from a list of templates.  And here, of course, we want to build a React project  and we want to build it with TypeScript.  So it's this first option here in my case,  which I'm picking.  And with that, if you then open this project in VS Code  for example, you get a typical React project structure  with some React code files, now just named .tsx  instead of .jsx because we'll write JSX code  but we'll also use TypeScript features as you'll see soon.  But you'll also notice,  if you take a closer look at this project,  that there is a tsconfig.json file,  and that in the end is a file that will configure  the TypeScript compiler.  You can add such a file to any TypeScript project  no matter if you're using vite or not.  But it is then a file that will be used  by the compiler to basically configure  how the TypeScript code will be compiled.  For example, which target JavaScript version  should be targeted,  and therefore how much your code should be converted  to all the run in older browsers.  Here, for example, we're targeting  a relatively recent JavaScript version  because here we might not be targeting super old browsers  where React also might not work.  So that's one file we'll take a closer look at soon.  In addition, as mentioned, it's now this vite build tool  which will automatically also convert this TypeScript code  to JavaScript code.  So as a developer, we'll just write our code  in these code files, and then once we're ready  to ship our application, it will be this build command  that we need to invoke.  And there you see that it's actually the TypeScript compiler  that's invoked, but it's a predefined command  that was created by vite here,  and that that TypeScript compiler is now installed  locally in this project here,  so it can be invoked from inside this project  even if you did not install it globally.  And then thereafter, the vite build process is invoked.  And for example, for the dev server  it's a combined build workflow  fully powered by vite.  Under the hood it will compile the TypeScript code  and start up that development server  where we can preview that application we're working on.  So all that is taken care of by vite  and we don't need to invoke the compiler manually.  Instead, we just need to run the commands  that are defined here in the package.json file.  And with that, let's take a closer look  at this tsconfig.json file  before we then thereafter finally get started  writing some React and TypeScript code.        

Understanding the role of tsconfig.json?
So before we'll write  any React TypeScript code,  let's explore this tsconfig.json file.  Now as mentioned,  this file contains the guess what configuration  for TypeScript.  For the TypeScript compiler to be precise,  though this ts config file will actually also be read  and picked up by the IDE we're using here  by Visual Studio Code,  and Visual Studio Code will adjust how it shows errors to us  and when it shows errors to us  based on the settings we have in this file.  Because it turns out  that you can configure TypeScript to be pretty strict,  mostly but not limited to this strict: true setting here,  which enables strict mode, which enforces more rules,  and more type related strictness.  And therefore of course when that strict mode is enabled  as it's the case here in this project,  TypeScript is stricter and the IDE, Visual Studio Code,  shows errors earlier than it would normally.  By the way, since it is possible that your tsconfig file  when you create a new project looks slightly different,  attached you find my tsconfig file  and attached you actually find my entire project setup,  also a version on CodeSandbox,  so that you can also follow along  with exactly the same project setup  and the same code I have.  And even if you do have the same tsconfig file as I do,  I still recommend that you use  that attached starting project  because in there I edited the src and public folders  to include different files than the default project has,  for example, different styles,  which we will use throughout this section.  So you should at least replace your src and public folders  with the attached ones.  So with the ones you find in the attached starting project.  But back to the tsconfig.json file.  In there as mentioned,  we can for example, set TypeScript to be stricter,  so to be less forgiving.  But of course there also are a bunch of other options.  And the good news here is that as a TypeScript developer  as a TypeScript React developer,  you really don't need to understand all these options  because there are a lot of niche and advanced options here.  Some options like this moduleResolution option,  which are really only important for that build tool  for Vite, which we're using under the hood,  and pretty much all these options are only important  for the build tool you could say.  And then some other options like this lib option,  which, for example, controls which built-in types  are available in this project,  for example, that we got some default DOM types available,  so that we can work with DOM elements  and we don't have to write the types  for such elements when we work with them on our own.  But in general, you can keep that tsconfig file as it is.  You could disable this strict mode  if you want a more forgiving, less strict mode,  which can be helpful if you are facing a problem  with some code where you just can't come up  with the right type.  But therefore this course will keep this set to true.  And therefore with that, we can finally leave that  and ignore this tsconfig file,  and instead in the next lecture,  get started with writing some code.  And therefore, with that, let's get started.  And the first step to get started here  is to actually run npm install.  No matter if you created a new project  or if you're using my attached project only on CodeSandbox,  you don't have to do that.  There if you are using the CodeSandbox starting project,  everything is set up for you already  and you don't have to run any code.  But locally, you should run npm install,  and then thereafter also npm run dev  to start that development server.  And with that, you should be able to visit localhost 5173,  and then see Let's get started! on that page,  and I'll keep that development server up and running  until we're done developing, which we aren't yet.

building the first component and facing a missing type?
Now  in this course section here,  we wanna build this goals app here  where we can manage the goals we have for this course.  And whilst this of course  will be a relatively basic React app,  it will be an app that allows us to explore  those core React and TypeScript feature  and how we can connect those features.  Therefore here, in this project, I actually wanna start  by adding a new components folder  because we'll need a bunch of components.  And then in there a CourseGoal.tsx file,  which should eventually contain a CourseGoal component.  Now it is dot tsx of course,  because it will contain some jsx code,  but we're going to use TypeScript.  And the appropriate extension for that is dot tsx.  In a vanilla JavaScript project, you would have jsx,  here its tsx.  In that file,  we should then export a component function  as our default for this file, for example,  just as you would do it in a normal React project.  And by the way, this course assumes  that you do have basic React knowledge.  If that's not the case,  I recommend that you go through my crash course  to which you find a link attached.  Of course, I then also got the React,  the complete guide course  at which you also might want to take a look  to learn all about React,  but you can get those basics from that crash course.  So here, I assume that you know these basics  and that you for example,  know that we can create a component in React like this  by defining and exporting a function.  And of course, React, as you also should know,  is all about creating and combining such components.  So here I want to be able to output a list of course goals.  And every course goal could therefore be such an article,  the default built built in article element,  which then for styling purposes contains a div,  where I have a h2 element,  which should output the title for the course goal.  Below that, a short description.  And then below that, a button, which we can click  to delete it from the list.  Now at the moment, we don't even have the logic  for adding it to some list,  but we'll eventually get there  and we'll eventually also make it deletable.  So that's the general structure of this component.  The goal, of course is to use this component  in the app component for now.  So here we wanna import CourseGoal from,  and then it's from components CourseGoal  and then here for Vite projects  it is considered a good practice  to add the file extension to these imports,  though it would work without that as well.  And with that imported, we cannot put that that here  in this app component.  There I just wanna render a main element.  And then here for the moment,  I'll just output the CourseGoal component like this,  not yet as part of a list instead as a standalone component.  Though of course we could output two course goals  if we wanted to,  but let's get started with one.  If we save that, we should see something like this  on the screen.  And of course, whilst that works  this is a component that's not too useful yet  because it's not configurable.  After all title and description are just placeholders here.  Now how do we change that and React?  With help of props.  And that's now the first time  where we'll have to write code that's different  from vanilla JavaScript React projects.  Because now that we're accepting a parameter here,  we should also define the type of that parameter  so that we get this extra type safety when writing the code  and that we get the extra auto completion  and we know which properties to find on this props object.  And at the moment we got no information about that.  Instead, at the moment, it's assumed to be any.  And we're actually getting a bunch of warnings  and errors here.  One of them being that it is implicitly of type any  because we haven't defined any other type  for this parameter.  And therefore then the default type that is assumed is any.  And we're now getting an error  because of that because we did set up strict mode  for this project, because strict is set to true.  And one of those extra rules that's enforced  by setting strict to true  is that you must not have untyped parameters.  So this implicit any is not allowed.  You have to explicitly set a type here  and make it clear which type of value can be expected here.  And that's therefore the next question,  which kind of value can we expect here?

Defining component prop types?
So here's our first opportunity,  and actually the first place where we have  to connect our regular React code  with some TypeScript logic.  We have to define the type of these props.  But what is the type of props?  Well, in the end, this props thing,  which is automatically passed to every component by React,  is just an object.  It is an object, in the end  that contains any key value pairs of our choice.  In the App component, we can, for example  add a title prop to CourseGoal  and then give it a title of Learn React + TS.  And we can add a description prop,  a description attribute you could say,  which should also contain some text here maybe  where the text could be,  "Learn it from the ground up".  That's how we add props.  And as you know, these key value pairs here  are then added as properties,  as key value pairs in the end still,  to this props object.  So here in CourseGoal.tsx, we can set the type of props  to an object type where we expect to have a title property  which will be of type string, and a description property  which will be of type string.  So that it's this object type  which we're expecting for our props.  Now, I'm still getting an error here,  mostly that I'm declaring it, but never using it,  but we're going to change this now.  Of course now, we can also use object destructuring here  so that instead of then using props.title  and props.description, we replace it here  in the parameter list,  with a pair of curly braces, opening and closing.  But here, on the left side of this colon  this is now not a type definition or anything like that  instead it's the standard JavaScript destructuring syntax  where we can now extract the title  and description properties from that incoming props object.  And then we can use title down here  and description down here  to output both title and description.  And with that we can save this,  and if we go back, we see our text here.  And therefore in the end, as you can tell,  setting this type is rather straightforward.  We just create our own object type,  because it's our component  and we control which data we expect to get there.  So we set up an appropriate type  and assign that as a type for this props object.  And then we of course  just have to make sure that we pass in the right data.  But TypeScript actually helps us with that.  If I would now try to add an ID here  and set this to a number, for example like this,  I would get an error here that my prop type here,  which is this object, is not assignable to,  in the end, a type that also has an ID property  because that's the case.  This object type here does not have an ID property  so trying to set such an ID prop correctly fails.  And that's that extra type safety we get  thanks to using TypeScript in our React project here.

Storing prop types as a Custom Type or Interface
So that's how we can define  the type of our props object  and that's a perfectly valid approach.  Now, defining this type in line, in this parameter list  can make this code a bit hard to read though.  After all, we got a lot of curly braces here  and if this would be a more complex object  we would have to write quite a bit of code here  before we get started with the component logic.  That's why we might want to use another feature  which I introduced in the TypeScript basics section  in this course.  We can create a custom type, a type alias  and we can cut this object type definition here  and instead create our CourseGoalProps type here,  the name of course is up to you,  and then store this object type in there.  And now use CourseGoalProps as a type for this props object  and that makes this code way more readable of course.  Alternatively, you could also use an interface,  like this, and that would also be perfectly fine.  You will see both approaches out there in the wild  in reactant TypeScript projects  and whilst you will read a lot of opinions on that  in the end it will come down to your personal preference,  which approach you prefer  unless you are working on some library  which you plan on distributing to other developers,  in which case you might wanna prefer an interface  because it's a bit more extensible  as shown in this TypeScript basics section.  But in your own project  it really comes down to your preference.  So that's one thing we might wanna do,  outsource the type like this.

Defining a Type for Props with "children"
So outsourcing the type like this  definitely makes sense.  Now, of course, as a React developer,  you might know that actually every props object  also has this special children property,  which is populated by React.  The idea behind this children property  is that we can wrap our component  around some other JSX code and then use that wrapped code  inside of the component.  And we'll use it in just a second.  And now the problem here with our course goal props  is that we don't have the children property in there.  And indeed, therefore, if I would try to extract children  from my props, I would get an error here  that property children does not exist on my props type.  And this is technically correct,  but of course as mentioned, in theory,  every component receives that children prop.  Well, the thing is if this component here  doesn't use the children prop,  you also don't have to set up a type  that theoretically gets this children prop,  because if your component is used like this  and is not wrapped around some JSX code,  the children prop will be undefined,  so you won't be able to extract  a renderable value in the end.  And, therefore, not being able  to extract it at all makes sense.  But if you want to use the children prop,  let's say here course goal should be usable  such that we actually do wrap it around this description  instead of setting the description as a prop.  If that's our goal, we of course have to tweak our type.  And we can do this here by now getting rid of description,  because I'm not setting that prop anymore,  I'm just setting the title.  And we now have to add this special children prop.  And the question now just is what's the type of that?  Is it string because this here is some text?  No.  This here is some text, but in the end it's JSX code.  It could be wrapped by a paragraph, for example.  That would be possible.  So it's not just text, it's actually JSX code.  And what's the type for that?  Well, the type is a special type that's built into React.  The React node type.  To be precise, it's not built into React,  but it's distributed as part of a type package  that was pre-installed in this project.  If you take a look at the package.json file,  you find these types packages here under dev dependencies.  One for React and one for react-dom.  And these packages contain extra type definitions  that you'll probably need  when working with React and TypeScript.  For example, this React node type,  which I'm now importing from React,  even though technically it's from that types package.  But you can kind of say that it's merged behind the scenes.  Now this is not an object or a function  or anything like that that we could use.  Instead it's a type and, therefore,  it's also a good practice to add the special type decorator  here in the import statement.  This is a special decorator that you can use  in TypeScript projects to make it clear  to the build tool, for example,  that this is an import that can be removed  in the code that should later run in the browser,  because the browser won't be able  to deal with types anyways.  Either way, with React node imported,  that's now the type we should set for children.  Because anything that's renderable,  in the end is such a React node  or is of type React node you could say.  So this JSX code here is of type React node.  And, therefore, now with that we re-added the children prop,  and we can now extract the children prop  and, of course, down here also output the children prop.  And I did now replace the entire paragraph  with it because in the app component,  I actually added these paragraph tags  around my description text.  With that, if we save that.  This looks as before and it still all works  without any errors.  Neither here in the IDE nor in that terminal  where the dev server is running.  And that's, therefore, how you can get hold  of that children prop again if you need it.  There also is an alternative approach though.  And for that I'll actually define this  with help of the type keyword.  Because you can also use another type provided by React  and that types package.  And that would be the props with children type.  It's also a type which you, therefore,  might want to decorate like this.  And it is actually a type that will give us  a props object that has this children key,  which is why we can extract children  down here without getting an error.  As you can see, I'm only getting an error for title  but not for children.  And you see that children here is of type React node,  the exact same type we manually set up here.  But, of course now it's only a props object  with children and not with title anymore.  That's why props with children is actually a generic type  which only works in conjunction with another type.  And that other type is your more specific props object  that contains all the other props you want  to accept here in this component.  So in this case, for example,  an object with a title property, which is of type string.  And that would be an alternative way  of defining our props here  with that special props with children type.  It is totally up to you  if you prefer this approach or this approach.  The important thing just is that you know  how to also get hold of those children if you need to.

Another way of Typing components
So now at this point  we learned a lot about typing props,  but it is important  because you're going to work with a lot of props  when using React and TypeScript.  There's just one last alternative syntax,  which I also want to explore together with you.  Because, of course, defining a functional component  like this with the function keyword  is just one possible approach.  An alternative, if I copy this return statement  and comment this out,  would be to create a constant, let's say, CourseGoal,  and then export that as a default, for example,  and set the value of this constant to an arrow function.  And then in here we can return our markup  and receive our props here.  Of course, we can now type the props  just as we did it before.  We can add our type like this,  and then extract title and children.  And everything works as before.  So that's absolutely valid.  But when using this syntax  where we create a constant or variable  and we then assign a function as a value like this,  when we use this approach,  we also have an alternative way of assigning our type.  We can add a type assignment here  to the CourseGoal constant in this case,  and set the type to FC,  which is also imported from React and which is also a type.  Now FC stands for functional component,  and this tells React that the function we do assign  in this variable or constant  will be such a functional component.  And FC is actually also a generic type  where the connected type is the props type.  So now we can set CourseGoalProps as a connected type  because this FC type internally is built such  that it's now this type that's used as a type  for the props object.  Which is why now extracting those props, again,  works without errors.  And that's simply another alternative syntax  which you should know.  There is no better or worse syntax here.  It really comes down to personal preference  but you will also see this syntax in a lot of projects  which is why you should also be aware of it.  With that, however,  I am actually going to comment out this code  and bring back that other syntax,  which I'll use throughout that course,  and move that up here.  Though, actually, below the type  so that that's the syntax I'll use.  But ever approach is fine.  I'm now just going to remove that FC import  because with that approach, I'm not needing it anymore.

Creating a Header component?
Okay, so now that we spent  a lot of time on props,  I now got a little exercise for you.  I want you to build a new header component  which can be used here, which should take two input values.  The first value should be an image prop,  which should actually receive an object as a value.  An object where I want to have a source property,  which should point at this image in the assets folder,  this goals JPEG image,  which you can import with an import statement  because that's supported by that underlying build process.  So we can import the goals image  from diving into the assets folder and then goals jpeg.  So that's the value for the SRC image.  And that in the end is just a string  because it will be a path to that image.  And the second value here should be an alt text  which is a list of goals  because that's, in the end, what will be on that image.  So such a image prop should be passed to header.  And then header should also be wrappable  to be wrapped around the H1 element  where I say Your Course Goals.  And your task now is to build that header component  in a separate file  and configure it such with TypeScript  so that it can be used like this.  Here's a short pause for you to pause the video.  Thereafter, we'll tackle this together.  So, did you succeed?  Let's build this header component together.  For this, in the components folder,  I'll add a new Header.tsx file.  And then in that file we want to export  a new function as a default, which is called Header.  Now, in here I wanna output the built-in header element,  and then in there have an image  which must be populated with help of the values  that are set in this object.  And I, of course, also want to output the wrapped content.  So below the image  I want to output the special children prop.  So of course, to make this component work  we need to accept props and we need to type these props.  And we can use one of the approaches  I showed you over the last lectures.  And it's up to you which exact approach you prefer.  I'll go for a custom type with the type keyword,  and set up my header props as an object  where I expect to get a children prop,  which must be of type ReactNode.  And that is imported from React then,  and it is a type, as mentioned.  Therefore I am marking it as such  with that special type keyword.  So that's the first step.  The next step is to make sure  that we also accept such a image prop  and define the type of that image prop.  Well, and the type in the end  should be an object type,  where the object should have two properties, src and alt,  where both properties contain values of type string.  So back here in the Header tsx file,  I'll add this image property  and set the value to an object type,  which you can do because in here we're defining types  and an object type is a standard type  as you learned in this TypeScript basics section.  And this, in the end, nested object type here  should then have the SRC property,  which will be of type string  and the alt property, which will be of type string.  Well, and that's now the shape of my HeaderProps object.  So, I'll set this as a type for props.  And with that, we could now access props.children,  or to make it a bit easier for us,  use object destructuring here to pull out the image  and the children prop,  and use just children down here.  And then on the image, we should set the source attribute,  the source property of the image to image.src  and the alt attribute to image.alt.  And since we're using the same names here, alt and src,  on that image object,  we can actually even shorten this if we want to  and just distribute the image object,  which does contain this source  and alt property onto this image.  That's a general React shortcut  which you don't have to use  but which you can use to make your code a bit more concise.  Which will simply take all the key value pairs in an object  and spread them as props, as key value pairs,  therefore, in the end, onto an HTML element.  With that, we got the finished header component  and back in the app component,  we therefore now just have to import header  from components Header tsx.  And with that, this should all work.  If we now save that, we should see this header here.

Using useState and Typescript?
Okay, at this point,  we really spent a lot of time on components and props,  it's time to move on.  And which other React concept is extremely important,  and is getting used in pretty much all React apps?  State.  Because whilst components  are those reusable building blocks,  state is what makes a React application  truly dynamic and interactive,  because state is the thing that, in the end,  leads to different UIs being rendered,  for example, in response to button clicks.  And speaking of that, here I will add a button,  and we'll later add a complete form,  but for the moment, it's just a button,  where I'll say Add Goal.  And, of course, the goal now is to add a new goal  whenever this button is clicked.  At the moment, with some predefined dummy data,  later, with custom data.  So, in order to make this happen,  I'll start by adding a nested function in the App function,  which I'll name handleAddGoal.  The name is up to you, but this is a common convention  for naming your event handler functions,  so, functions that should be triggered upon some event.  An alternative would be addGoalHandler,  you also see that a lot.  And in the end, the name is up to you,  it just should describe what the function does.  And here, the goal is to dynamically add more and more goals  to this app.  So, therefore, I'll add the onClick prop to this button,  the built-In onClick prop,  and point at handleAddGoal here,  so that this function is triggered  whenever this button here is pressed.  And in here, I now want to generate new goals,  and then dynamically output them on the screen.  And for that, as mentioned, we'll need state.  And we can register some state here in this App component,  of course, with help of the built-in useState hook,  which must be imported from React,  and which is now not just some type,  but instead a real function that we can execute.  Now, as you know,  useState returns an array with exactly two elements,  and the first element is the current state snapshot  for this current function execution cycle,  the second element is a function we can call  to update that state snapshot,  and to trigger this component function  to be executed again, therefore,  because that's how React works.  So, here, I wanna manage some goals,  and therefore my initial state could be an empty array.  And then here, in handleAddGoal,  we can add the logic for manipulating this array  with help of setGoals.  But before we do that,  there's one important problem we should solve,  or one improvement we should make here.  If we hover over goals, we see the type of that,  and at the moment, it's never array,  an array of nevers, which sounds pretty weird.  What does this mean?  In the end, that TypeScript's way of expressing  that this here is an array of unknown types,  and therefore we'll actually also never be able  to tweak this,  because if I, for example,  try to set goals to an array of numbers, I get an error,  because I haven't defined which types of values  should be allowed in this array  when I initialized the state.  So, the general problem which we have to solve here  simply is, that when using React with TypeScript,  and when using useState in such projects,  we have to tell React which type of value  we're going to manage with useState.  Sometimes, it's able to infer this.  If we would set this to some initial text, for example,  it would then infer that goals is of type string.  But for more complex types, like arrays,  which is, as you learned in the end,  a connection of multiple types,  the array, and then the type of value in the array,  in such cases, TypeScript, of course,  is not able to infer anything.  That's why useState is a generic function,  and allows us to add these angle brackets  to pass this extra type information  between those angle brackets.  So, in case of useState,  we can use these angle brackets to set the type of value  that will eventually be managed by that state.  And here, we can make it clear  that this should be an array of course goals,  which, in the end,  should be objects with a title and a description,  and maybe also an ID,  which we'll need later for deleting them.  That's why I will add a new type here, CourseGoal,  which will have a title of type string,  and a description of type string,  and then also, let's say, an ID of type number, maybe.  And with that type defined here,  between those angle brackets,  we can say that the state we want to manage here  should be an array of CourseGoals.  And, as you learned,  that's the syntax for defining  that you want to have an array of a certain value.  The alternative would be to use  the built-in generic Array type.  One of the two must be used here,  and with that, setting our goals to an array of numbers,  of course, will fail,  but now goals, on the other hand,  is inferred to be of the correct type,  and that now allows us to update the type accordingly,  as long as we do it in a correct way.  So, as long as we make sure that goals ends up  being such an array of CourseGoals.  And that's therefore now how we should write the code  in this handleAddGoal function.

Working with state & Outputting state based values
So to update this state here  in handleAddGoal,  I'll use this function form for updating my state  because the state will be updated  based on the previous state snapshot.  And as you also learn  in my "React - The Complete Guide" course,  if your new state depends on the old state,  you should use this special function form  for updating the state.  Because here you'll automatically  get your previous state snapshot at the point of time  where this state updating function here  is executed by React.  And then here in this function body,  you must return the updated array, in this case,  the updated array of goals.  Well, and here where I want to add a new goal,  that in the end just means  that I want to spread my existing goals array  into this new array.  So I wanna copy all the elements of the existing array  into this new array,  and then add a new object,  a new object of that shape  to be precise to the end or beginning of that array.  So here, all created in a separate step  to keep that code readable,  and add a new goal constant here,  which should be of type CourseGoal.  And I'm adding this explicit type assignment here  to force me to set up a correct value here  and to get better autocompletion  where the IDE now suggests these property names.  So that's another use case  for using explicit type assignments to get this extra safety  so that I don't accidentally set up the wrong type  and to get that extra IDE support.  And then here I can set the id,  let's say to Math.random,  which is good enough for this demo project,  set the title to Learn React + TypeScript in this case,  for the moment, it will be hard-coded,  and set description to Learn it in depth,  which of course means that at the moment  we'll always add the same goal,  but that will of course change soon.  And with that, it's now this new goal,  which is added here in my case,  at the end of this returned new state snapshot,  so that new goals array  that were in the end setting up here.  And with that, we can now finally use goals  to dynamically output this list of CourseGoal components.  And that of course works just as you know it.  We can use this goals state, and then the map method  to convert this list of CourseGoal objects  to a list of CourseGoal components,  for example.  And for that we pass a function to map  where we get our individual goal  and where we then return the element  we want to output for every goal.  And here I actually want to output a list item,  and then in that list item, my CourseGoal component.  Because I will actually wrap that entire list  with the unordered list element  so that we got a semantically correct piece of code here.  Now what's really great about TypeScript  is how well it's able to understand your code  and infer types in different places of your code.  For example, TypeScript understands how map works  and it understands that this goal,  which we get as a parameter in this function here,  will be of type CourseGoal  because TypeScript understands  that this function here will be executed for us  by the browser in the end.  And that this value will automatically be populated  and that we will get the values of this array here.  And since this array contains a bunch of course goals,  TypeScript understands that an individual item of that array  will be of type CourseGoal.  And that gives us extra type safety  and great autocompletion here.  For example, when setting the title,  I can now type goal.,  and my IDE understands  that I can now either access the title,  description, or id property  because these are the three properties  I set up in my object type here.  And with that, we can output the title here,  and then output goal.description here  between the paragraph tags.  And then on the list item,  also add the special key prop  which React once when outputting such a list,  which should be said equal to goal.id here.  And with that,  finally, we can save that all.  And if we go back here,  we got this button  which we can press to output a bunch of course goals.  Again, for the moment, they're all the same,  but we got no error here in the console,  no error in our code,  and also not in the terminal,  and we therefore now also know  how to useState with TypeScript  and how we can make sure that TypeScript understands  which type of value we wanna manage here.

Resuing Types across files ?
So slowly but steadily,  this application is taking shape  though of course at the moment we're just working  with some dummy data here.  Before we're going to change that,  I first of all wanna make sure  that this delete button works though.  And I actually want to make my app component  a bit leaner at least,  and outsource this entire list markup  into a separate component.  And that's therefore the first thing I'll do here.  For this, of course, we can add a new component.  The CourseGoalList.tsx file  could hold the CourseGoalList component function  and you can now of course definitely also try creating  that component function and using it in the app component  on your own.  The goal is to get this code  into this CourseGoalList component function.  You can pause the video here and try it on your own.  I'll do it together with you in just a second.  So let's do that together.  For that, I'll start by cutting this unordered list  from the app component and returning it instead here  in the CourseGoalList component function.  Now of course, this component now needs access  to the goals state and we get that access  of course with help of props.  In the end, those goals are just props we should get here  in this component function.  Therefore, we can again set up our own type here.  The course goal list props object.  And as you know, you could also create an interface  and then here expect to get our goals.  And the goals here should now be an array  of course goal objects which have this shape.  Therefore, of course we can copy this shape  and use that here and add square brackets thereafter  so that it's actually an array of such objects,  which we want here, not a single object.  With that, we can set our props here  in that CourseGoalList component  to that props type we just added  and also use destructuring here to get hold of goals.  And with that we can then map through the goals again  and everything works except for this component  where the import is missing.  So now here we can import CourseGoal.  So this component from CourseGoal.tsx.  And now this all works here in this CourseGoalList.tsx file.  And back in the app component file  we can get rid of this CourseGoal import  because we're not using this component here anymore.  And instead import the CourseGoalList component  from the components folder  and there the CourseGoalList.tsx file.  And it's then this newly imported CourseGoalList component,  which I want to use down here  and which now needs that goals prop,  which should be set to that goals value.  That value here refers to my state  that I'm managing in the app component.  This gold's property name refers to the name I chose here  for this property in my CourseGoalList props object.  So that's how this would work.  And as you see, if I save this,  the app still works as before.  But this solution has a small flaw  and the flaw is of course,  that I copied this type definition.  Now I have the same type definition in two places.  Here in the CourseGoalList component  and then also here in the app component.  And that's bad,  because if I ever decide to change this type definition  because I also wanna include a image or something like this,  I have to change it in two places.  And that's always bad.  In programming, you always wanna avoid situations like this.  But there is a very simple convenient solution,  because when using TypeScript, you can export types.  I mean, we already saw how we can import types  like here this props with children type,  which I decorated with the type keyword,  which is optional though.  But that's how we can import types.  Of course, we can therefore also export them  simply by adding the export keyword  in front of the type that we wanna export.  And we could also export an interface, by the way  if you went for an interface instead of a type alias.  So we can export a type like this  and we can now use one at the same type  in multiple files therefore.  We can use it here in the app.tsx file,  but we can now also go to the CourseGoalList.tsx file  and import our type from the app component.  So from the app.tsx file.  The only problem we'll face here  is that we now have a name clash  because my type name, CourseGoal  is the same as this component name  and that is not allowed.  And even adding the type keyword doesn't  change anything regarding that.  That's just an annotation that helps the build tool  get rid of unnecessary imports  when it prepares the code for production,  but it does not solve this name clash.  Instead to solve this name clash,  we can use the same solution we would always use  for solving name clashes due to imports.  We can assign an alias to that import.  So we can give this imported thing  this imported type, in this case, a different name  in that file into which we're importing it.  For example, CGoal, or anything like that.  And now it's that name, which we refer to in  this file if we want to use this imported type.  So here, instead of manually repeating  or copy and pasting this type definition,  we can now use this CGoal type here.  So this imported type here in the end  as a type for our goals.  Or to be precise,  we make it clear that it's an array of such course goals.  And that's then the type here.  And that's the more elegant solution  because now we only define the type once  and we then use it in different places.

Passing functions as values - In a Type safe Way?
So now that we got  the CourseGoalList component,  I wanna make sure that we can also delete goals  and not just add them to the list.  For that, I'll start by going to the App component again.  And in that app component we wanna add a new function  which can be called handleDeleteGoal  to be in line with the naming I chose for adding a goal.  Now here the assumption could be  that we expect to get the id of the goal  that should be deleted.  And since my goal will have number IDs,  that id that I'm getting here should also be of type number.  And then we want to add some code here  that removes a goal by that id,  which is pretty straightforward to do.  we call setGoals to update the state  and we again, use that function form  to get access to the old goals in a safe way.  And then we wanna return a new array  which is the old array minus the goal with that id.  And for that, we can use the built-in filter method  which is built into the browser.  Filter can be used to generate a new array  from an existing array.  For that, filter receives a function  which will be executed on every item in the array  and it will get that item as an input.  So they offer an item of type CourseGoal in this case.  And then here we should return true  if you want to keep an item  and false if you wanna drop it.  So of course I wanna keep all items  except for the item that has  the id I'm getting here as a parameter.  So, my condition here for getting true or false is that  I check the id of a specific goal  and if it's not equal to the id parameter here.  So if this id parameter is not equal  to the id stored in a goal,  then I will return true and keep the goal.  If they should be equal though,  this condition will yield false  and the goal will be dropped.  And that's how we can get rid of goals in our list.  Now we just need to connect this function here,  to this Delete button,  which we already have in the CourseGoal component.  And that of course means prop drilling.  We need to pass this function as a value  through multiple layers of components.  We could alternatively also use the Context API  or a solution like Redux,  but we'll explore these things later in the course.  For the moment we'll use good old props  and we'll therefore pass this handleDeleteGoal function  as a value to CourseGoalList  and then from there, to the CourseGoal component.  But let's start in CourseGoalList.  There, I now want to receive a prop  that will hold this handleDeleteGoal function.  So we need a prop which will get a function as a value.  So which type is a function type in the end.  And the type of function we are expecting,  is a function that will get one parameter of type number  and that won't return anything.  So in CourseGoalList in my props object,  I'll add a new prop which I'll name onDelete,  which is a common convention in React projects  to name props that receive functions as values  by using this pattern  and naming it like an event handler.  And the value then is a function type as mentioned  where I expect to get one parameter  which could be named id here,  but that's not too important.  More important is the type number  and the return value type which is void  because I don't expect this function here  to return anything.  With that, we can extract onDelete here  from this props object  now that we added it here to the props type definition.  And we can pass it to CourseGoal.  There, we could also add our onDelete prop  and forward our onDelete.  And to make this less confusing,  I'll actually rename onDelete here  in the CourseGoalList component to onDeleteGoal  and extract onDeleteGoal here  and then pass onDeleteGoal as a value to onDelete.  And that's now a prop we have to add  to the prop type of CourseGoal.  This onDelete prop here.  And it will of course essentially be the same prop  as we have it here in CourseGoalList props.  So we can actually copy that,  and then go to the CourseGoal.tsx file.  And then there in that file,  we can go to our CourseGoalProps  and add that here to that object  so that there we now add onDelete.  That was the name I chose here for my prop.  So in CourseGoal, it should be named onDelete.  It should have this function type as an expected value type.  And then here we can extract onDelete like this  and then use that to assign it to this button like this.  Though as you can tell, I'm now getting an error here  and that's a pretty long and intimidating error.  But in the end, the problem here is that,  onDelete will get a function of this type.  So expecting one parameter returning nothing,  the parameter is of type number,  but onClick expects to get a function as a value  that receives an event object  which should be of type MouseEvent.  Because all those built-in  event handling props like onClick,  give us event objects which are emitted automatically  when a user event occurs.  And sometimes we need those event objects  to get useful information out of them.  Now here I actually don't care about it,  but it's still not the information that should be passed  to this incoming onDelete function.  And indeed we would not get the id that we wanna have  when setting onDelete as a value for onClick like this.  Because the default click event when triggered,  does not magically emit that id of the CourseGoal.  That's some application specific logic after all,  not related to the default button.  Therefore, what we should do here,  is wrap onDelete with an anonymous function like this,  which is now the function that's passed to onClick.  And there we could accept that default event object  which is of type MouseEvent connected to the button element.  But since I don't care about it here, I'll omit it.  Now, we just have to manually invoke onDelete here  in the body of this anonymous function  and then pass that id which onDelete wants to it.  Because onDelete is a function  that needs that number id as an argument.  And currently we're not setting it.  Now currently I don't have  the id of the CourseGoal in this component,  but we can of course change that.  We can expect the id property here,  the id prop in our props object,  which should be of type number  and then extract it here.  And then pass that id to the onDelete function.  With that, this component will work as intended.  But of course we now must make sure,  that we also do pass that id to the CourseGoal component.  So back in the CourseGoalList component,  we should now not just set title and onDelete,  but instead, also set the id prop here  and set it to goal.id,  so that this id is available  inside of the CourseGoal component.  And with that we'll have all the information we need  and we're forwarding  that handleDeleteGoal function as needed.  At least as soon as we set this onDeleteGoal prop  on the CourseGoalList component in the App component  and set it equal to handleDeleteGoal.  Now with that, we got the entire chain of props set up  with support of TypeScript.  So by also embracing TypeScript  and setting up all the right types,  and we were able to avoid an error here  when we might have accidentally assigned onDelete  directly as a value to onClick.  So TypeScript helped us there.  And with all of that, if we save that and go back,  we can click the Delete button to delete events.  And that's of course an important step forward.

Handling & Typing Events?
So now that we're able to delete goals  and also handle clicks on that delete button,  it's time to finish this basic app here  by replacing this Add Goal button here  which currently just adds a bunch of dummy goals  with predefined text with a form  that allows the website users to enter their own custom data  and add goals with their own title and own description.  For that, I'll therefore add a new component  in that component folder,  and I'll name it NewGoal.tsx,  or to be precise, that's the file name,  but in there I want to have a NewGoal functional component.  And this component here, this component function  should return a form, the built-in form element.  And in that form I then want to have two inputs  wrapped by a paragraph each,  where the first input is connected to a label  where the label says your goal,  and then we have the input element  and the input will receive an id goal, could be the id,  and we connect the label by adding the htmlFor prop here  and by pointing at that goal id then.  This input should be of type text  because I want to get some standard text here,  and I also need a second input and label.  So we can copy that first label input combination  and add a second label where we say short summary  and where we point at an input with the id summary.  And this input should also be of type text.  So that will be a basic form with two input elements.  Below that I also wanna have a last paragraph  which then should contain a Add Goal button.  And here I actually won't add the onClick prop  to that button because since we're in a form,  this button will by default submit that form  and trigger the submit event of that form,  and we can simply handle that  by adding the onSubmit prop to that form.  And then we just have to add some logic  to handle that form submission.  So for that, I'll add a nested function  in that NewGoal component,  which can be called handleSubmit.  And it's now this function which I want to connect  to this onSubmit prop,  or which I want to use as a value for this onSubmit prop.  And that's all pretty standard up to this point.  But now you might recall that in React,  when handling a form with React, it is quite common  to prevent the browser's default behavior  which would be to send an HTTP request  to the server that's serving this website.  Now we don't want that here  because this server is not prepared  to take any incoming form submission requests,  and therefore we want to call event.preventDefault in here.  The problem just is that for that of course  we need to accept this event argument  and that on its own isn't a problem actually  because onSubmit, this prop,  will automatically call this function  which we pass as a value to onSubmit  with such an event input argument.  So we'll automatically get such an event object by React  and the browser in the end when that submit event occurs,  but we face a problem here because we're using TypeScript  and this now implicitly has the any type,  because of course we as a developer know that this will be  the FormEvent object that's automatically passed by React,  but TypeScript doesn't know,  because TypeScript doesn't understand  that connection like this.  So we have to explicitly set a type here.  And the type I wanna set here is a very specific type  that is provided by React.  It's the FormEvent type,  which should be imported from React.  And it is a type so we can annotate this with type  to again make it clear that this import will not be needed  when the code is prepared for production  because it's just a type that we need  during development when writing TypeScript code.  So with that, that event is properly typed  and we cannot remove that question mark  that was added for me here.  It was added automatically for me when I wrote this code  because my IDE thought that event might be undefined  and therefore preventDefault should be called conditionally,  but that's actually not the case here,  here with that type definition  I am making it very clear that event will always be set,  that it's not optional or possibly undefined  and therefore we can call preventDefault like this.  And we will always get such an event of that type  due to how we use handleSubmit.  By passing it as a value to onSubmit,  React will give us an event of that type.  So that was a lot of talking about that,  but it is important to understand  that sometimes your event handling functions  must be typed properly to correctly reflect  the type of event that is being emitted.  As a side note,  if you would've defined an inline event handler,  so an inline anonymous function down here,  then event would automatically be inferred  to be of type FormEvent.  It would automatically be inferred to be of that type  because when adding it here directly as a value  for onSubmit, instead of defining it standalone,  TypeScript is able to infer that type.  But when you define it as a standalone function  you could of course be using it anywhere  and it's not clear that it will only be connected  to onSubmit or that it will be connected to onSubmit at all,  and therefore then, when defining it standalone,  you have to explicitly set that type.  And with that, I'll go back to the solution we had before.  I just wanted to share  this extra piece of information with you.  And with that, before we continue working on that form  and before we actually handle the entered values,  we can now use this new goal component  and I wanna use it in the app component,  because in the app component  I got this dummy Add Goal button,  and we can and should now replace that button  with that NewGoal component we just worked on.  So I'll add it here, and of course for that to work,  I also make sure that we got this fitting import here.  Now with that, handleAddGoal is currently not getting used,  but we'll take care about that later.  For the moment, if we save this  and we take another look at the running application  you should see that now you got this nice form here,  and therefore now, as a next step,  we can bring that form to life.

Working with generic event types?
So now that we got  our base form set up here, it's time to make sure  that we also extract the entered information.  Now we got a couple of different options  for doing so and I do cover all those options  in way greater detail in my React to complete guide course.  In this course.  I'll instead focus on one of those three options.  Now, one option you could use, which we'll not use here,  but which you could use, would be to useState  and two-way binding to get the current value.  Often input on every keystroke the user makes  by using the useState hook.  That would be one common choice.  An alternative approach would be to use  the built-in FormData class that is provided by the browser.  So that's built into the browser and can be used  like this, to pass the eventcurrentTarget to it.  Now this will be the form element and form data  will then automatically get all the input values  of that form and make them accessible  on that form data object.  Though, to access the entered input values,  you must assign the name attribute to every input  because it's then this name  by which you can extract information  from that form data object.  So that can be a very convenient way  of extracting that data.  And now as you see at the moment, if I try  to use this approach, I'm getting an error here though.  And the problem here is that TypeScript  doesn't fully understand  that the target of this event will be this form element  because theoretically, such a FormEvent doesn't have  to come from the onSubmit prop of a form.  That's why this FormEvent actually is a generic type  and therefore, can be enriched with extra type information  about a related type.  And in this case, the related type of the form event  is the HTML element or the type of HTML element  that is responsible for this event.  And the correct type to choose here,  to add this extra information that this event will be coming  from a form element is the HTML form element type.  Now that's a type built into TypeScript or to be precise,  it is a type that is available  because in the tsconfig.json file,  we added this lipb setting or to be precise,  this setting was there right from the start  by default in this project and this lib setting,  in the end controls, which base types should be available  in TypeScript in general.  And here, we unlock some general JavaScript base types  and some DOM specific base types.  And this HTMLFormElement is one  of those DOM base types.  So that type can be used like this without adding an import.  And with that, this error goes away  and we could use this form data object  to extract the input values of that form.  By the way, I'm using current target instead of target here  and I'm getting an error if I use target  because target is technically not guaranteed  to be that form element, current target is.  Even though in most cases they should refer  to the same thing to this form element here.  Nonetheless, this is also not the approach I'll use here,  but I'll keep that generic type annotation here  to make it clear that this form event type can be annotated.  But the approach I wanna use here  in this course is to use Refs  for extracting those input values.  So I'll remove that name and instead  in the next lecture,  we'll get started using the useRef hook  in React with TypeScript.

Using useRef() with Typescript?
So let's use refs for extracting  those input values  because that's, of course, also a pretty common thing  to do in React apps.  Now, for that, we can create refs  by using the built-in useRef hook that is provided by React,  which is not a type but instead just like useState,  a function you can call in your code  and useRef, when called, gives you a ref object.  Now here I need one object for my goal  and I need a second ref for my summary.  And you can of course give those refs any names you want.  Now that those ref objects are created, we can connect them  to those DOM elements which we want to access  in our code later with help of the special ref prop  that can be used on those built-in elements.  So here on the first input  I'll set my goal ref as a value for the ref prop.  On the second element, I'll set the summary ref as a value.  But as you see, this doesn't seem to work.  Instead here we're getting an error and it's pretty long  and complex error that can look quite intimidating.  Now we can see that it seems to be related  to undefined being used somewhere as a value type  and that this is not assignable to a value  that should be of type HTMLInputElement or null.  And by the way,  when going through TypeScript error messages  that are a bit longer like this,  it's typically the most nested, the inner message  that helps you the most.  You can typically ignore those outer messages,  though they, of course, also might contain  some useful information, but it's mostly the inner message  that helps you the most.  So here the problem is a undefined value being used  somewhere where we want  an HTMLInputElement value or null.  And the problem simply is that these refs by default,  out of the box, contain undefined  as a default starting value and the ref prop  is internally typed such that it does not accept such refs  that contain undefined as a value.  The solution therefore is simple.  You should add null as a starting value here,  by adding null as an initial value to the useRef hook.  This might sound like it's the same,  but it does make a difference for the ref prop  as you can see.  And it also signals a different intent in the end.  Undefined means that there is no value at all,  null typically means that we don't have a value yet  or that we temporarily, or under certain conditions,  don't have a value which is exactly the case here.  We have no value initially because the connection  hasn't been established the first time this executes,  but will eventually have a value.  We'll have this input element as a value.  So with that, the error goes away.  And with that we can then, of course, get our enteredGoal  by using this goal ref object  accessing the current property, which you always have to do  because the object useRef gives you  is always an object with a current property.  And then that current property will refer  to this input element.  So here we can then access the properties and methods  of that DOM input element, like the value property.  But wait a second, we're getting an error here  and we're getting an error here  because as we can see, goal.current is possibly null  and that's true, it's null initially  so it could be null here, at least in theory.  But, of course, here in our code  we know that this will never be the case  because handleSubmit is used as a value  for the onSubmit prop on the form,  and therefore it will only ever get executed  after this code has executed.  So after this JSX code has been parsed  and after this ref connection has been established.  So we as a developer know with certainty  that this will never be null.  And you can express that certainty  and let TypeScript know about the fact that you know  that this will never be null by adding an exclamation mark  after the potentially null value.  With that, you're basically telling TypeScript,  hey, this here will never be null.  If it then turns out to be null at runtime  your app will crash.  So you should really be sure about that.  But with that, we're still getting an error here,  a different error, but an error.  And the error is that property value does not exist  on type never.  So what does that mean?  Well, of course here we as a developer know  that this goal ref will eventually refer  to such an input element, but TypeScript does not know that.  It does not read our entire code base  and try to understand that code base.  And just from the code we wrote, it's not clear.  Here it's just clear that goal initially has a null value  and then thereafter TypeScript doesn't understand  that when this function gets executed  the value in goal.current will be such an input element.  So we have to tell TypeScript about that.  And thankfully that's fairly easy to do  because useRef turns out to be a generic type as well.  A generic type where you can add this type annotation,  so you don't have to, just as with FormEvent  where it was also optional,  but you can add this extra type information  to pass extra information about the related type of useRef.  And what is the related type of useRef?  Well, it's the type of value  that will eventually be managed by useRef.  That could be a number or a string  or any value of your choice including object  or array values because, of course, refs,  as you also learn in my complete guide course,  can be used for managing any kind of value.  You are not limited to using refs to connect  to HTML elements, even though that is a common use case,  but you're not limited to that.  But here of course, we are using this ref  to reach out to this input element  and therefore the correct type to use here  is HTMLInputElement,  which, just like HTMLFormElement, is a type  built into TypeScript so you don't have to import it.  And we can also add that to the second ref now.  With that, you see that the error went away here  because now indeed TypeScript does understand  that current is either null, which we can rule out here,  or it's an HTMLInputElement.  And that element has a value property.  And indeed now I'm also getting great auto completion  and IDE support here, and I can browse  through all the different properties and methods  the underlying HTML input DOM element object has.  In this case, it's that value property I'm interested in.  Now, similarly, we can also get the enteredSummary  by using summary.current and then exclamation mark  because we know that it won't be null.  And then, of course, just as before, .value.  Now I'm just getting some errors here  because I'm not using enteredGoal  and enteredSummary and that's therefore,  of course, what we'll change in the next lecture.

Handling user input in a type-safe way?
So we're almost there,  we're extracting those ref values,  and we typed those refs correctly.  Now I wanna pass that enteredGoal  and enteredSummary information from the NewGoal component  to the App component where I have the handleAddGoal function  that will be interested in those values.  Therefore, back in the NewGoal component,  I wanna receive a prop here  a prop that will then receive a function as a value  because I wanna pass a pointer  to this handleAddGoal function  down to the NewGoal component.  So that handleAddGoal stays in the App component,  where I have that state which I'm managing,  but we can invoke it from inside the NewGoal component.  And for that we can, of course,  add the NewGoalProps type here.  You could also add an interface instead as mentioned before.  And then there at a onAddGoal prop,  which will be a function type  because I'm expecting a function as a value  as I just mentioned, and it should actually be a function  that takes two string values as input  because I plan on passing the enteredGoal  and enteredSummary string values to that function here.  The function should then return nothing.  So void is the return type.  And now here we can add the props object  and set its type two NewGoalProps,  and of course then also use destructuring therefore,  and pull out that onAddGoal function,  and then inside of handleSubmit call onAddGoal,  and pass enteredGoal as a first argument,  and then enteredSummary as a second argument.  So these two string values are passed to that function.  With that back in the App component,  we should pass handleAddGoal as a value  for that onAddGoal prop  to the NewGoal component.  Now for that as a first step handleAddGoal  must accept these two string arguments  because otherwise, it will be an invalid function type.  This currently is a function that does not  take any parameters and that's the wrong type.  So here I expect to get my goal, which is of type string,  and my summary, which is of type string.  Now the function is typed correctly  and we can now use that goal to set the title instead  of setting it to a hard-coded value,  and to set the description instead of setting that  to a hard-coded value.  The rest of the code can stay as it is.  But now we should use the handleAddGoal function  and use it as a value  for the onAddGoal prop on the NewGoal component.  And that should be it.  That should make sure that this function is called  from inside handleSubmit in the NewGoal component.  And hence, if we save that and I reload,  I should be able to add a new goal,  like this, click Add Goal, and here it is.  And I can add multiple goals with different text.  And you see that this is being reflected down there.  And of course we can also still delete those goals.  That hasn't changed.  Now as a last step to complete this NewGoal function  and this form handling logic,  I also wanna reset the form whenever a new goal was added.  And there again would be different ways of doing that.  But since we're getting this event object,  which we did type properly here in handleSubmit,  one of the easiest ways of resetting the form  after extracting the values from the inputs,  which of course is important.  If we reset it too early, we get the wrong values.  But after getting those values,  we can use event.currentTarget,  which is guaranteed to target the form element  and call reset like this.  That's a built-in method provided by the form element,  which is the current target of this event,  and therefore this built-in method will make sure  that the inputs inside of the form do get reset.  So with that, if I go back again,  if I add a New goal,  you see that now the inputs get cleared  after submitting that goal.


