Why React & TypeScript?
So let's start  with the most important question first,  why would you use TypeScript with React?  And the answer isn't really related to React.  Instead, the answer is why, in general,  you would use TypeScript.  Because it adds type safety to your JavaScript code.  It can lead to better JavaScript code  because it can help you catch errors earlier.  Not at runtime,  but instead whilst you are still writing code  and that's therefore, of course,  also the case when using TypeScript with React.  There it's easy to overlook a prop  that needs to be added to a component  and that then causes issues if it's not there  and it's also easy to pass the wrong type of data  to a prop, for example,  or mess up other type-related things  and with TypeScript, you simply see those errors earlier.  You see them whilst you are writing code  and you can therefore then fix them immediately.  Now, using TypeScript also sometimes means  that you need to write slightly more complex code  than you would normally write  because clearly defining the right type  in the right situations can sometimes be tricky,  though honestly, in most cases, it's not  and that's, by the way, also why I created this course,  to show you how you can use TypeScript  with React in general, but of course, also,  to dive into these slightly more complex scenarios  and problems that you might also sometimes face.

Type Inference & Explicit Type annotation?
I'll add a new file, first-app.ts.  The file name of course is up to you  but it must end with dot ts to signal to the IDE  that this file will contain TypeScript code  because Visual Studio Code  and actually most modern web development IDEs  have great TypeScript support built in  and therefore as you will see,  we'll get many TypeScript errors and hints  without even invoking that TypeScript compiler.  Instead, the IDE will help us when writing TypeScript code  but for that it needs to know  that we are writing TypeScript code  and we are telling the IDE with help of that extension.  And now in here we can write regular JavaScript code,  like this.  This is valid standard JavaScript code  and it works inside of a TypeScript file as well  because that's really important,  a really important takeaway.  When working with TypeScript,  you in the end still write JavaScript code.  You still use all these JavaScript features,  you know, and later once we switch to React with TypeScript,  you will see that you write React code as you know it,  but when working in a dot ts file, when using TypeScript,  therefore, you also get some extra features available.  For example, if I now set userName to 34,  which doesn't make a lot of sense, I guess,  I'm also getting an error here in the IDE.  That's that built in TypeScript support  I already mentioned.  If I hover over this error, I see that the type number,  which I'm trying to assign to this variable  is not assignable because that variable seems  to be of type string  and we would not get this error  if this would be a JavaScript file.  If I changed the extension here,  you see that the error goes away  because that here is valid JavaScript code,  but it's not valid TypeScript code  because the idea behind TypeScript is  that types are enforced  and that we get strict type checking,  which basically means that TypeScript wants  to help us avoid type related errors.  And this year would be such a type related error.  We initially store a string value  in userName and then we suddenly store a number.  That's probably not what we want  and that's why we're getting this error.  Now the error goes away  if I don't assign an initial value though.  Because if I don't assign an initial value,  TypeScript is not able to infer  which type of value should eventually be stored  in that variable.  And you can see which type TypeScript is inferring  for a variable by hovering over that variable.  Here you see that it's the any type that's being inferred  because it's always this part after the colon  that describes the type of a variable in this case.  Now previously, if I go back,  when I assigned that string here, the text Max  that inferred value instead was a string value.  That was the inferred value here.  But without that initial value being set,  TypeScript is not able to infer a value  and therefore it does allow that number here,  but it actually then also allows a string thereafter  because it essentially now has no idea  regarding the type that should be stored here,  and therefore for this variable,  it now falls back to the default JavaScript behavior,  which is to allow all types to be stored here  because that's how JavaScript works.  Now therefore, in situations like this  where you are working with a variable  that doesn't have an initial value,  you as a developer might want  to explicitly assign a type when you create,  when you declare that variable.  So here in this line, line one.  And you can do that by adding a colon  after the variable name,  and that's now not standard JavaScript syntax.  Instead, that's now TypeScript specific syntax,  adding such a colon after a variable name  because it's that colon that now separates  the variable name from the type you wanna assign  to that variable.  For example, here, we could then enter string as a type  because that's one of the built-in types  TypeScript supports, and I'll show you more built-in types  in just a second.  And with that we're now overriding  that inferred any type that we had before  and we're explicitly telling TypeScript  that the type of username must be string  and therefore now we're getting an error  when we try to store a number  because of course the type number is not a string.  So that would be an explicit type assignment.  And it makes sense in cases  where TypeScript can't infer the type you want it to infer  and where you still want strict type checking,  which you typically always want when using TypeScript  because why would you use TypeScript  if you would not care about types?  It's literally its main feature.  Now, you can also mix this explicit type assignment here  with a value assignment like this,  but in cases like this assigning a type explicitly  as we're doing it here typically doesn't make a lot of sense  because TypeScript would be able to infer the type anyways.  So you can still add this explicit assignment,  but you typically wouldn't because it does make sense.  You would only do that in more advanced scenarios  where the inferred type maybe isn't the type you want,  but here that's not the case.  But now you know about the general idea of TypeScript  and about type inference and explicit type assignments  with that special colon syntax  and we saw TypeScript in action.  Let's therefore now explore some important basic types  and what we can do with TypeScript.

Basic primitives?
Now TypeScript ships  with a bunch of built-in basic  and also some more advanced types.  Now, one basic type we already saw is the string type.  Another type would, of course, be the number type.  If I store a number in a variable  it's automatically inferred, and we could, of course,  also explicitly set this to type number if we wanted to.  So the number type  is another crucial built-in type you can use.  Of course, yet another pretty basic value type  you use a lot in JavaScript is the Boolean type.  So if I store true in here,  this is inferred to be of type Boolean.  So the true or false values are reflected  by that Boolean type.  So string, number, are basically the most important  built-in basic types that you will use all the time.

Invoking the TypeScript compiler?
So now that we learned  about some basic types here,  it's, of course, good that we have them and that we're able  to write TypeScript code and that we can, for example,  add those explicit type definitions.  But how exactly do we get this TypeScript code  into the browser or  into our Node.js environment and execute it there?  Well, for that, we must compile it as mentioned before,  and as mentioned before, this can be done  with help of that TSC command, which is available  if you did install TypeScript globally on your system.  Otherwise, you can use NPXTSC to invoke it  on demand without even installing it globally.  You then simply add the file name that contains  the TypeScript code you wanna compile.  After this command, make sure that it's saved and hit Enter.  And with that TypeScript, we'll go ahead,  check this code for errors, and then convert it  to regular JavaScript code that you could then execute  in the browser or with Node.js, which is why now,  I also have this JavaScript file here  and this file now contains almost the same code  but without the type annotation, for example.  So, without all these TypeScript-specific features.  In addition, here you see that actually let was replaced  with var even though let is  also a standard JavaScript keyword  but out of the box by default.  TypeScript actually also converts the code such  that it works in older browsers.  This can be disabled and is something we'll take a look at  at in the next course section.  But the most important takeaway is  that you invoke the compiler  by running this command and targeting a specific file  and that during this compilation process  all those TypeScript-specific features will be removed.  Now, when writing TypeScript code  you will actually rarely run the compiler  during development though,  because the IDE already shows you  all those important errors.  For example, if I try to assign a number here,  I'm already getting an error here in the IDE  which allows me to fix it.  I could save this and try to compile it,  and I would then get my compilation error here,  where I also learn that I'm trying to assign an invalid type  but that's some extra unnecessary work.  I can simply rely on my IDE instead.  And therefore, here in this section,  we're actually not going to use the compiler a lot.  Instead, we're only going to work in that file  and in that IDE,  and dive into all those important TypeScript features  in theory, before we then also see them  in action in the next course section.  And with that, let's continue now  that we know about these basic types  and we know how to work with them with help of the compiler.

Combining type union?
Now, sometimes in TypeScript,  you have a variable that should not be limited  to one value type.  Let's say we have a userID variable here,  and the idea is that userID can be abc1, for example,  but it should also be allowed to be 123.  So it should be either a string or a number,  both should be allowed.  And by default, when I write this code, that's not the case.  You see, I'm getting an error here,  because, of course, userID is inferred to be of type string  because I assign a string initially.  Now, that's one scenario  where you might want to explicitly set the type,  even though it is being inferred,  but you might wanna set it explicitly here  because it's the wrong type that's being inferred.  But what should the correct type be?  Well, it should be a so-called union type,  basically, an alternative of multiple types.  It should be either a string or a number in this case.  And, in TypeScript, you write this like that.  You use this pipe symbol like an OR operator here,  you could say,  and with that, you are telling TypeScript  that userID is either of type string or of type number.  And that's why, now,  we're no longer getting an error down here,  because we can now store a number in userID.  Now, we can't store a boolean value, for example.  Here, we still get an error,  because a boolean is neither a string nor a number,  which I guess makes sense.  But being able to set a type to one of multiple types,  so, being able to give TypeScript alternatives,  is another very important feature that you will use a lot,  as you will also see throughout this course.

Working with object types?
So we don't just have  these basic value types,  we can also combine them.  But TypeScript got more essential types built-in  or support for essential types, I should say.  Let's for example, say that,  we don't just wanna define all these user values  as individual variables,  but that we want to group them into an object.  That would be a pretty common task.  So we could create a new variable user,  and then as a next step, we might want  to store an object in that user variable  where we have a name property and a age property,  and then maybe also isAdmin property which is true or false.  And we could of course also add an id, which is abc  or which maybe should also be allowed to be a number.  So we have that user object,  and as you see I can store it in this variable  without getting an error  but that's only the case  because I did not set an initial value here.  And therefore, user, as you learned, is of type any.  So any value is allowed,  and that's never a great type to have  because it doesn't give us any extra type safety.  So what we want to do here is,  we want to tell TypeScript  that user should be an object.  Now we could achieve this by explicitly setting user  to type object like this.  That's another type that's built-in.  With that, you see,  we're not getting an error here,  and I would on the other hand,  get an error if I try to store a string  because that is not an object.  It's a primitive value, a string value.  That's why I would get an error here.  But the object type isn't that great.  Because whilst it does now prevent us  from storing a string in user,  it does not give us any hints regarding  the structure of the object that should be stored here.  At the moment, I could store  a user object like this in user,  but I could also store an empty object  without any key value pairs.  And whilst that might sometimes be what you want,  it's not what I want here.  I want to make sure that user must always be an object  with exactly that structure.  So with a name key, which should hold a string,  an age key which should hold a number,  and isAdmin key, which should hold a Boolean value  and an id key, which should hold  either a string or a number.  And that can be achieved by not using this object type  but by instead defining an object type like this  by adding curly braces,  opening and closing after that colon.  Now we're still in the type assignment area here,  so don't confuse this for the syntax for creating an object.  We are not on the right side of an equal sign here  as we are down here.  Down here, we are creating a value, here we aren't,  instead, we're creating a type  and that difference is really important.  Here we are setting the type for the user variable  and now we can set that object type  just as we would create the value  but by defining the types for the different keys.  So we could say that this object should have a name key  but now after the colon here,  we define the type of the value  that should eventually be stored under such a name key.  So in this case here, string,  because I plan on storing a string here in name.  Then since we are defining a type here, not a value.  We add a semicolon, whereas in the value we use a comma,  in the type definition it's a semicolon.  Though a comma would work, but a semicolon is more common.  And then we add the next key value pair H, for example  which should be of type number.  Then for isAdmin, I want to have a Boolean value.  And then for the id, I want  to either allow a string or a number  so it's string or a number written like this  with that union type feature.  And with that, we're now setting user  to an object of that shape  which is why I can now store this user  in that user variable that works as you see.  But if I uncomment this code, I would get an error  because storing such an empty object,  of course, is now not valid anymore  because this object does not have this shape here.  And that's how we get extra type safety  when working with objects.

Working with Array Types?
So object types are another  crucial built-in feature offered by TypeScript.  Another very common type would be an array type.  For that, let's say that we have a hobbies variable  which initially might be undefined  but which eventually should store an array of hobbies  like sports, cooking, reading, something like this.  Now, at the moment, of course this works  because hobbies is of type any, but as mentioned before,  that's typically not what we want.  So we wanna explicitly set a type here.  But what should be the type?  Well, we want to have an array in here,  and indeed TypeScript offers an array type, though it starts  with an uppercase A, not array with a lowercase A.  That's important.  As you can see though, if I try to use it like this,  I'm getting an error  that a generic type Array T requires one type argument.  Now we'll get back to generic types later.  In the end, what this means is that this array type  only works if you give it more information  about other related types.  Which makes more sense if you consider that such an array  in the end, of course, is the combination of two values  and therefore value types.  It's an array, that's the main value,  but it's an array of strings here.  That's the related value.  And that's therefore why this array type  needs to be written like this  with these strange angle brackets  that wrap the related type.  So the type of values this array contains in this case here.  So that's how we would say that hobbies should be an array  of string values.  And as a result, we, for example,  are not able to store a bunch of numbers in there  because that's an array,  but it's not an array of strings, of course.  Now that here is one way of writing it,  but it's also a pretty long or complex way.  Therefore, you'll also often see this shortcut.  This is the same kind of type in the end.  This means that hobbies should be an array of strings,  and of course, you don't just have string arrays.  You could also have number arrays  or Boolean arrays or also arrays of objects, for example.  You could have a type like this where you are saying  that you want to have a bunch of objects  of that structure in an array.  And we will see such slightly more complex types  later in the course  and also in the React projects we're going to build.  For this introduction, it's just important to understand  that we do have types like this.  And therefore with this array type  and this object type as well as the union type feature  and all these basic types, string number and boolean,  we got a solid TypeScript foundation  on which we can now build up on to dive into  more important TypeScript features, which we will need  in order to use TypeScript with React later.

Adding types to functions - parameters & Return Value Types ?
So now that we explored these basic types  and these core concepts,  let's take a look at where in our code  we can use such types.  And of course, we already see  one very common use case here, a variable.  Assigning types to variables is extremely common.  Now, by the way, of course,  you can also assign types to constants.  For example, if I had an API key constant here,  we could do that.  But since it's a constant, you, of course, typically  don't set the type explicitly because a constant always  has an initial type from which the type  can then be inferred.  And this inferred type here, by the way,  is even a bit stricter.  It's not just any string, but it's exactly this string here  because a constant can't be reassigned anyways.  That is the idea of a constant.  You cannot reassign it.  But variables and constants are one construct  where you can use types, or where you do work with types.  Another very important language feature  where you'll use types are functions.  We can use types in functions, for example,  for the parameters.  If we create an add function  that should receive two parameters,  we might want to add types to those parameters like this,  by adding a colon after the parameter name.  So after A and B.  And then by setting the type after that colon.  That would, for example, enforce that this add function  is called with two arguments where both arguments  are of type number.  And of course, we could mix and match those different types  just as we need it.  We can also accept more complex types here,  like objects with fields inside of them.  You can use all those types here and you therefore  can make your functions more type safe.  Then here, we can of course work with those values.  And therefore, for example, here,  this result constant is inferred  to be of type number because A and B are numbers.  So TypeScript is really smart regarding that.  And we could, for example, output that.  What we can also do with functions and types  is define a return type.  So the type of the returned value.  Now this add function, which I created here,  doesn't actually return any value.  So we could set the return type by adding a colon  after this parameter list.  That's how you set a return type.  By setting it to undefined, which is another built-in type.  This would say that this function yields undefined  as a value as a return value  because it doesn't return anything.  But for this specific scenario, for function return types,  we got a better type that you should use instead  if you have a function without a return statement.  And that's the void type.  Another type built into TypeScript that's meant to be used  in conjunction with functions.  And to be precise there, it should be used  as a return value type as we're using it here  if you have a function that doesn't return anything  so instead of using undefined  which you could technically use, you should use void.  And that's how you could set a return type.  Now, if your function does return something,  we would therefore get an error now  because we now are returning a number  when we're saying that we're not returning anything.  So if we are returning something,  we wanna set our return type to that.  So in this case, to number.  Though you can also omit that return type,  since TypeScript is able to infer  that we are returning result here, which is of type number.  And therefore, if you hover over add,  you see the function type definition here,  you see the parameter types,  and you see the inferred return type here.  So that would also be possible to rely on type inference,  but you can also explicitly set the return type  if you want to.  Typically, you wouldn't do that though.

Defining Function types?
Now when working with functions,  it's important to understand and keep in mind  that in JavaScript functions are of course regular values.  So if I create another function, calculate,  that, for example, receives two numbers  and then a third argument  that should be a calculation function,  that should be executed on these two numbers,  I can do that.  This is valid JavaScript code,  because in JavaScript you can use functions as values.  So here the calculate function,  which I defined expects a third parameter,  which should be a callable function.  Now, since functions are values in JavaScript,  you of course also might want to set a type here,  a function type.  And we see such a function type here,  if I hover over add.  This in the end is the type of this add function.  That's how such a function type is defined in TypeScript.  It's the combination of a parameter list  and the return value type in the end.  So if you have a place where you are working  with a function as a value,  you can also therefore define such a function type.  Though the syntax for defining such a function,  (indistinct) looks slightly different,  you basically create an arrow function here, you could say.  But keep in mind that we are in a place after this colon  after this parameter name, where we define a type  and not a value.  So this here is a type creation, not a value creation.  Nonetheless, it looks like an arrow function,  because that is the TypeScript syntax  for creating such a function type.  And there you then have your parameter list,  like this, for example.  And then after the arrow here, your return type.  And if I reformat that, that's a bit easier to read.  And this would now say that calc function  wants a function as a value.  So a value of type function.  And it shouldn't be any function.  Instead, it should be a function with this signature  with this configuration, so to say.  A function that gets two input parameters,  which are both of type number,  and which then returns a value of type number.  And therefore, with that setup,  we could call this calculate function  by passing two numbers to it  and a pointer to this add function.  This add function, keep in mind,  is a function with such a signature.  It is a function that takes two parameters,  which are both of type number,  and which then returns a number.  So it fits this type definition,  which is why we can call calculate like this.

Creating custom types / Type Aliases?
So functions and types being used  in conjunction with functions and function types  are some important TypeScript features,  which you must know.  But here, when we take a look at this code example,  you'll also see one potential problem,  which you'll sometimes encounter  when working with TypeScript.  Your type definitions can get rather long,  like this function type definition  for the calcFn value here.  Now this is not a big problem here,  but we might want to outsource this type definition,  and you can do that in TypeScript.  You can create custom types,  you could say, so-called type aliases  by using the type keyword,  which is not a standard JavaScript keyword,  but instead a keyword made available by TypeScript.  And this type keyword allows you to create  a custom type, you could say,  or to be more precise,  to assign an alias to some other type.  So a custom name to some other type.  For example here we could name our type AddFn,  and this name is entirely up to you.  And then you add an equal sign,  and now even though we have an equal sign here,  since type is a keyword provided by TypeScript,  which is there to allow us to create our own types  on the right side of this equal sign,  we don't create a value with which we work in our code,  but we instead create a type,  for example, we can copy this type definition,  and use that here  on the right of the equal sign.  And with that, we would store this type definition  under that name, so to say.  So that now down here, we can use this AddFn type,  this custom type.  And we can, of course, also reuse that,  and use it in all the places  where we're working with an object of that type.  And this is therefore  another super important TypeScript feature,  which you'll use a lot,  because you cannot just use it for function types,  which tend to be rather long, but for any type.  For example, also up here,  where I had this userID,  which was a string or a number,  we could also create a type alias here,  and name it StringOrNum, for example,  and then store this union type under that alias,  and use that alias name here in the place  where we had the union type.  And that's indeed another very common scenario  for using this type keyword  that you're storing union types with a custom name.  Another common scenario are object types.  You can also use the type keyword here  to, for example, create a user type,  and then store this object type definition under that name,  so that down here you can refer to your custom type.  And this could then also, of course,  be reused in all the places  where you want to use that type.  So that type keyword, and this feature,  which allows you to create custom types,  or to be precise, assign aliases to other types,  is a feature you'll also use a lot in TypeScript.

Defining Object Types with Interfaces?
So this type keyword  and this feature here is an important one, as you learned,  but when it comes to defining object types  that's just one option you have.  Another option is to create a so-called interface  with help of the interface keyword,  which is also provided by TypeScript,  and which is also not built into JavaScript.  Now, you use this interface keyword  by then adding any name of your choice after interface.  For example, credentials.  Though this name here is up to you  just like this custom type name here.  It typically starts with an uppercase character, though,  even though that's not a hard rule,  but it's a common pattern.  And then the difference to the type keyword,  or one difference,  is that you don't define the type  separated with an equal sign here,  but instead you add curly braces after that name.  Because the interface type  is essentially for creating objects.  I'm saying essentially  because you can also define function types with it,  but that's not too important here,  and not something you'll probably use a lot.  And, therefore, the most common use case  for the interface keyword is to define object types.  So, you have the interface keyword  then your name and then the curly braces.  And then here you have your key value pairs,  though again, not to create an object value here  but instead a type definition for an object.  So any key name of your choice,  but then the type of the value  that should eventually be stored under that key.  So for example, string here.  And that could then be our credentials object.  We can then use this credentials object,  like this for example,  and then set creds equal to an object  where we now have to add password and email.  And you'll also see that  if you open the auto completion, here,  I'm getting this suggestion for email  and not for any other keys  because of course TypeScript and My Code Editor  understands that creds is of that type,  and that in there we only have these two key value pairs.  So we're getting great IDE support here,  and we can then store our details here.  So that's another way, another popular way,  for defining object types.  And you now, of course, might wonder  why you would use interface if you have type and vice versa.

Interfaces vs Custom Types?
So we can use both the type keyword  and the interface keyword for defining object types.  I had that user object type defined  with the type keyword here.  And we had this credentials object type here defined  with the interface keyword.  So when would you use which?  Well, in general you can always use the type keyword,  and that also allows you to define other types  than object types as you're, for example, seeing here  in line 53, in my case here with that example  with that function type that's being stored  in a custom type with help of the type keyword.  Interface is more limited when it comes to that,  because it's basically limited to object types.  Nonetheless, the interface type also has some advantages.  For example, if you're defining a class of credentials,  for example, you can use the implements keyword  to implement an interface.  And this then forces you to add the properties and methods  that are defined in the object of that interface  in your class as well.  So here I now have to add the email and password,  key value pairs to that class  if I'm implementing this interface.  And then I could also add additional properties  to this class, but I have to at least implement these.  So you can use interfaces as contracts,  you could say classes have to adhere to  if you are implementing them.  And you could then, for example, create a login function  where you expect to get credentials of type credentials.  So of your interface type.  And log in could then be called both with the creds object  that I created earlier.  So with that object that is of that interface type.  But we could also call login  with a new instance of Auth credentials  since that also implements credentials,  and therefore TypeScript knows  that this will also be a valid object  that has at least the properties and methods  that are wanted by that interface.  So this feature where you can implement interfaces  into classes can be a reason for using interfaces  over the type keyword if you are working on a project  where you are using classes,  which many JavaScript projects don't,  but if you have one that does,  interface might be a bit bit better.  Another reason for using the interface keyword  for defining an object type is that it's easily extendable.  You can simply redefine the same interface  with the same name without getting in an error  and add more properties or methods to it.  Now you might wonder why I would do it like this  and not just add it here,  but that can be useful if you are, for example,  creating a library which you are sharing  with other developers from all over the world,  and you have your interface definition  in some part of your library,  but you want to allow those developers  to easily extend your interface.  With that feature, which is called declaration merging,  that's quite easy to do without any extra effort,  because those developers can basically just redefine  your interface with your name and add any properties  or methods they need without any extra work.  So that can be another reason  for using the interface keyword.  In basically all other scenarios,  and therefore, in the end, in most use cases.  it therefore doesn't matter. if you use interface  or type and you can use whatever you prefer.

Merging types ?
Now, regarding types and interfaces  and object types, there's one other important feature  you should be aware of.  Let's say we have a type Admin, which is an object,  where we maybe have a permissions property,  which should be a string array.  And then we maybe have another user type or AppUser,  since I'm already using the name User  up there in the my file here so here I'll name it AppUser,  where we maybe have a username.  And now we maybe wanna create a new type, AppAdmin,  which should be the combination of these two types.  Now, of course we could merge the types manually  but we might have a reason for keeping them separated  because maybe somewhere else in the app  we need just an Admin or just an AppUser type.  So we wanna have these separate types  but we also wanna create a merged type.  Now of course we could now manually create  such a merged type by copying all those different properties  into a new type object.  But that's unnecessarily cumbersome.  After all, we already do have our type definitions here.  Well, we could use a union type  but that would not give us the desired result.  Now AppAdmin is not a merged object but in the end  just one of these two types.  So it's allowing both types in a value of that type  instead of merging the types.  To merge the types, we need the & operator instead.  With that, AppAdmin is the combination of these two types.  So if I'm creating a new admin variable,  which is of type AppAdmin, and I then assign a value,  that must be an object with both a permissions  and a username property.  And permissions is then an array,  an empty array or an array with strings,  and username also must be a string.  And that's how we can merge such user types.  We can also merge types if we went for the interface keyword  instead of the type keyword.  So for that, I'll comment out that code  so that we can still see it but it's no longer active.  And I'll copy this object type definition down here  to define it as an interface, Admin.  Then I'll also add an interface, AppUser,  which has that username, and we could now create  a new AppAdmin interface, which extends Admin.  So it's this extends keyword that now makes sure  that we take all the properties and methods  that are defined in another interface,  the Admin interface in this case, and merge it  into this new interface which we're creating here.  And we can extend multiple interfaces here,  separated by a comma.  And then we could add any additional properties  which we might need here or we keep this empty.  And with that, if I copy this code here from above  where I'm using this AppAdmin interface,  this code again works but now using interfaces  instead of the type keyword.  As you can see, if I now remove one of these properties,  I'm getting an error because username is missing  despite being required by AppAdmin.  So that's how you can merge multiple object types  when using the interface keyword.

Being specific literal types?
So at this point we of course covered  a lot of important TypeScript concepts here  and we're almost done for this module,  but we're not done entirely yet.  Instead, there still are a few main features  I still want to cover before we explore React  in conjunction with TypeScript.  Now, the first important feature are so-called  literal types in TypeScript.  And for that, let's say that we wanna have a role variable,  which should be either admin or user or editor,  but not any other value.  Now, of course for that, we could set role to be a string  and with that we could store admin and user  and of course also editor in there.  But, as you might already guess,  we can also store any other string in there.  And that's not really what I want.  I don't wanna accept any string in here  but one of these strings.  Now for that we can use this literal type feature  I already mentioned.  You can set a specific value, for example  a specific string as a type.  So keep in mind here we are in TypeScript land.  After this colon, after the variable name  we are in TypeScript world.  So here I'm not really creating a string value  but instead a specific string type  that's limited to a specific string value though.  At the moment to an empty string,  which could be the value I want, but it isn't here.  Instead here we could use admin as a value.  That forces role to be only that value,  that specific string.  Which is why now here we're not getting an error anymore  whereas for all the other string values we do.  Now of course here I want to allow multiple values.  And how can we do that?  Well, by creating a union type, by accepting alternatives.  So we can use the pipe symbol here to also  allow the value user and also the value editor.  You can also create number literal values.  So now, for example, the number one,  and only that number, would also be allowed,  but here it's really just these three strings  which I wanna allow.  And therefore, now here if we try to store A, B, C  we're getting an error  and all the other strings work just fine.  And that's there for another pretty important  and common feature  when writing applications with TypeScript.

Adding type guards?
Now when working with union types, no matter  if you are using such literal types or more general types  like just string or number, it is quite common  that you sometimes have code that should only be executed  if you have a value of one of the accepted types.  For example, we could add a function, performAction,  where action is maybe any action described  by any string, but where we then want to get the role  of the user that's currently locked in.  And that should be either admin, user, or editor.  So as a first step, so that I don't have  to copy and paste that,  which I could of course do, but which is unnecessary work  and makes that function definition longer.  To avoid that, I'll add a custom type, which I'll name Role  which stores that union type and which I can now use here  and also here in my function definition.  With that, I have a function that wants an action  and a role, which is either admin, user, or editor.  But now here in perform action we might wanna check  if role is admin because only then we might want  to execute that action.  Therefore, we can add a if check here  and check if role is equal to admin.  And as you see, I'm getting great auto completion  by my IDE here because it understands that role  can only be admin, user, or editor  due to the way this type is set up.  And we can check if role is equal to administration  and if that's the case, I want to run my action.  So do something here and otherwise I don't do anything.  And this might seem obvious, but it is an important pattern  especially when working with union types  that you add if checks to your code  to check if you have a certain value  and then you execute different code for different values.  Now, if action would be either a string or a number  we could therefore, for example, also add another check,  maybe nested in here as a separate if statement.  Or by adding a condition here.  We could, for example, check if type of action  is equal to string.  Now the type of operator  is a default operator built into JavaScript.  It's not coming from TypeScript.  It can be used to get the guess what?  Type of a parameter or variable.  And as a result you'll get a string that contains  the built-in types, for example, string.  And now we would only run this code if the role is admin  and we got an action that is of type string, not a number.  Otherwise, if we have a number or a different role  this code in the if statement would not execute.  So having extra guards, type guards you could say, like this  in conjunction with union types is a common pattern  which you will also see from time to time in this course.  And it is there therefore a pattern I wanted  to cover here already.

Making sense of Generic Types?
Now, the last feature,  the last important TypeScript feature  I definitely want to cover here in this introduction  is the generic types feature.  Now, you might recall that I mentioned this feature earlier  when we created this array.  If I have a roles array,  that should be an array full of roles,  I could create it like this.  I'm using my custom Role type for that,  and then this built-in Array type,  which is such a generic type as I mentioned before.  And as you can see, if you remove this related type,  then we learn that this generic type  requires one type argument,  and such a type argument is passed  with help of those angled brackets.  Now, roles would only accept my Role strings here,  and not any other strings.  Now, I did mention  that we could have also written it like this,  and it would've basically worked in the same way.  Nonetheless, this here is an example for a generic type,  a built-in generic type.  But you can also build your own generic types,  and you might now wonder why exactly you would do that,  what the benefit of that is,  and what exactly generic types are in the end.  Well, as mentioned, generic types are types  that work together with another type.  And Array works together  with the type that's inside of the array, for example.  Now, we don't just have built-in generic types,  like Array here, so built-in types  that need another type to be specified in a precise way,  so to say,  but we can also build our own generic types.  For example, we could build a DataStorage type here,  which should be an object type in the end,  where I wanna have a storage property,  which should be an array,  but an array full of data which I don't know in advance.  So, I don't know yet what the shape, or the type,  of data will be that should be stored in there,  it could be a bunch of strings,  it could be a bunch of objects.  Therefore, we need a type placeholder here,  or, put in other words,  this DataStorage type which I'm creating  will be connected to another type,  it will need extra type information to be truly specific.  And therefore I wanna create a generic type here  where I expect extra type information  at the point of time where this data storage type  is going to get used somewhere in my code.  And for that, we can add angled brackets here,  after the name of this custom type.  And then add any placeholder name of our choice  between those angled brackets.  Typically, you use T for type,  but any name and any character of your choice is fine.  You could also have multiple placeholders here  if you were building a more complex generic type  that needs multiple related types,  but, here, I'll just go with one for now.  And now, I can set the type of storage to an array of T's.  So I know it will be an array,  which, itself, ironically, is a generic type,  but it will be an array full of values  which types I don't know yet.  And we could then, for example,  also add a method to that object  by adding a property,  and then using a function type as a value,  because that is what a method, in the end, is,  it is a property that stores a function.  And then, here, in this add method,  we will probably expect to get some data  as an argument, as a parameter.  And now, the type of that data, of course,  will also be that generic type placeholder,  because, again, we don't know it yet,  DataStorage can be used with all kinds of data later.  And then here, this function, this method,  will probably not return anything.  It could return the updated storage,  so we could return this storage array here, for example,  if we wanted to,  but here, I'll not return anything.  And we can of course also add a delete method  if we wanted to,  but here, I'll keep it simple and just add data.  So now, with that,  we have a custom generic type here.  And now we can use this type  to create multiple storages for different data,  because it's a flexible, a generic type.  So we could have our string, or our textStorage here,  which should be of type DataStorage,  but now, here, we wanna store a bunch of strings  in that data DataStorage,  so I pass string as a value for this placeholder.  That's how that works.  This value here,  between the angled brackets here  when I'm defining my concrete type,  that string value is used as a value  for this T placeholder in my generic type definition.  And with that,  we now create a DataStorage object here in the end,  which will have our storage array,  which, initially, might be empty,  but which must be full of strings,  because we defined that here,  that the storage must be an array  full of values of that type,  and that type here now is a string.  And we add our add method here,  and that add method now also must accept data,  which is automatically inferred to be of type string,  because, again, that's what I defined here  in this general generic type definition.  That data, this argument here, this parameter,  is of that generic type-type, so to say,  so it will be of type string down there.  That's how we define and then use a generic type.  And then here, we could add any logic we want,  for example that we simply reach out to this storage  and push our data onto it.  Now, of course,  we could now also create a userStorage, for example,  where we also use that DataStorage type,  but where we now expect to get user data in it.  So here, that storage array  is now an array full of User objects in this case,  so I'm only allowed to add objects that have this shape  with these properties,  and the add function therefore expects  to get a user of type User, with which we can then work.  And that's the idea behind generic types,  you define them once but, in a flexible way,  and you can then use them  in conjunction with specific other types in different places  to, for example, store different data,  or do whatever you need to do with different data.  It's worth noting that, in TypeScript,  you can just define generic types like this  with help of the type keyword,  instead you can, for example,  also define a so-called the generic function  by using the function keyword,  as you always do if you want to create a function,  and then here we could, for example, name that merge,  and add the angle brackets after the function name  to then maybe use two placeholders,  again, with any names of your choice,  but T, and then U, are common choices,  so that we can accept two parameters  which use these different placeholder types.  And we then maybe return a new object  which is the combination of a and b,  with help of the spread operator  that's built into JavaScript.  And now we could use this function by calling merge,  and we can then add the angle brackets here  and define the shapes of the two types  that we wanna use for the parameters.  So for example, here, both types should be objects,  and the first object should have a name property  which is of type string,  and the second object should have an age property  which is of type number.  So, with that, I am setting up my connected types  for this generic function,  and I'm therefore telling TypeScript  which kind of data is expected for these two parameters.  So, when I now pass these parameter values,  I have to pass two objects as values,  and the first object must have that shape,  because I'm setting up this object type definition  as a value for this placeholder.  And I'm then saying that that should be used here  as a value for the first parameter,  therefore, that's now the shape I have to use here  for that first argument I'm passing to merge.  I have to add a name property here.  And for the second argument,  I have to use the shape of the second generic value,  so, the value I'm using for the U placeholder here.  In this case, I want to have an age here.  Well, and with that, I'm getting such a User object,  which is actually a name I'm already using here,  so I'm naming it newUser to avoid name clashes.  And now, newUser has an age and a name property,  And I'm getting auto completion here, because TypeScript,  and therefore, also my IDE,  understands that I'm passing these two objects  as values to merge,  and it knows the shape of these objects  because I defined this as a generic function,  which works with different related,  but clearly specified, types,  and that's what we're doing here.  And here, we could actually even remove these angle brackets  and these type definitions,  because when we have such a generic function like this,  and we're then passing values  for these different parameters  which are connected to different type placeholders,  if we do that, TypeScript is able to infer  that the value passed  must be of the type of this first type placeholder,  since I'm using the T type for the first parameter,  and the value used for the second parameter,  or the type of that value,  must be the type of that second placeholder in this example,  since I'm using that U type placeholder  for the second parameter.  So, typeScript is able to infer all these things,  and I still get this auto completion and this type safety.  And whilst this generics feature  therefore might still be a bit confusing,  it is a crucial feature which you will also encounter again  later in the course,  and which I therefore wanted to mention here already.




